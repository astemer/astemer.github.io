<!DOCTYPE html>
<html>
  <head>    
    <script>

		var debugSeverityLevel = 2;
		var debugLogsEnabled = true; // <<===
    var watchProcess = null;
		var gps_coords = {lat: 0.0, long: 0.0};
		var map_coords = {x: 0.0, y: 0.0};
		var simulatorlocations;
		var simulatorlocationsIndex;
		var simulatorMode = false; // <<====
		var map_orient_data = {alfa: 0.0, ratioX: 1.0, ratioY: 1.0};
		var dataJsonStr = "";
		var mapOrientData = {
			vector: {angle: 0.0, dist: 0.0}, 
			vectorRatio: 0.0, 
			p1: {lat: 0.0, lon: 0.0},//Top left 
			p2: {lat: 0.0, lon: 0.0} // Bottom right
		};
		var historyPointsMinDistance;
		var id = setInterval(timeTick, 200);
		var canvas;
		var context;
		var historyPoints = [{x: 0.0, y: 0.0}];	
		var tailPoints = [{x: 0.0, y: 0.0}];
		var tickNumber = 0;	
 
    function initiate_watchlocation() {			
			if (watchProcess == null) {
				watchProcess = navigator.geolocation.watchPosition(handle_geolocation_query, handle_errors,
			    {
						timeout: 10000,
						enableHighAccuracy: true,
						maximumAge: Infinity
					});
			}
    }
 
    function stop_watchlocation() {
		  if (watchProcess != null) {
				navigator.geolocation.clearWatch(watchProcess);
				watchProcess = null;
			}			
    }
 
    function handle_errors(error) {
            switch(error.code)
            {
                case error.PERMISSION_DENIED: alert("user did not share geolocation data");
                break;
 
                case error.POSITION_UNAVAILABLE: alert("could not detect current position");
                break;
 
                case error.TIMEOUT: alert("retrieving position timedout");
                break;
 
                default: alert("unknown error");
                break;
        		}
    }
		
    function getCurrentLocation() {
			if (navigator.geolocation) {
				navigator.geolocation.getCurrentPosition(handle_geolocation_query);
			} else {
				x.innerHTML = "Geolocation is not supported by this browser.";
				x.text = "Geolocation is not supported by this browser.";
			}
		}

		function applyLocation() {			
			var x = document.getElementById("newLoc");
			var newLocStr = x.value;
			debugLog(3, "applyLocation: newLocStr: " + newLocStr);
			newLoc = newLocStr.split(",");
			debugLog(3, "Str: " + newLocStr + " Arr: " + newLoc[0]);			
			setPosition(parseFloat(newLoc[0]), parseFloat(newLoc[1]));		
		}

		function setPosition(lat, long) {
			debugLog(3, "setPosition: lat: " + lat + ", long:" + long);
			gps_coords.lat = lat;
			gps_coords.long = long;
			var infoBox = document.getElementById("info");
			infoBox.value = lat +  ", " + long;						
			map_coords = latLon_2_xy(lat, long);
			addTailPoint();			
		}

		function addTailPoint() {
			dist = distance(map_coords.x, map_coords.y, tailPoints[tailPoints.length - 1].x, tailPoints[tailPoints.length - 1].y);
			if (dist > tailPointsMinDistance) {
				tailPoints.push({x: map_coords.x, y: map_coords.y});
			}
			if (tailPoints.length > 20) {
				var lastPoint = tailPoints.shift();
				addHistoryPoint(lastPoint.x, lastPoint.y);
			}
		}

		function addHistoryPoint(x, y) {
			dist = distance(x, y, historyPoints[historyPoints.length - 1].x, historyPoints[historyPoints.length - 1].y);
			if (dist > historyPointsMinDistance) {
				historyPoints.push({x: x, y: y});
				if (historyPoints.length > 1000) {
					historyPoints.shift();
				}
			}
		}

		function showHistory() {
			context.lineWidth = 1;
			context.strokeStyle = "red";			
			historyPoints.forEach(drawHistoryPoint);
		}

		function showTail() {
			context.lineWidth = 1;
			context.strokeStyle = "pink";			
			tailPoints.forEach(drawTailPoint);
		}

		function handle_geolocation_query(position) {
			debugLog(3, "===> handle_geolocation_query: lat: " + position.coords.latitude + ", long:" + position.coords.longitude);
			setPosition(position.coords.latitude, position.coords.longitude);			
    }        
		
		function showPosition(x, y) {
			debugLog(3, "showPosition: x: " + x + ", y:" + y);			
			//drawXonCanvas(x, y);
			drawLocationIcon(x, y);
		}

		function drawHistoryPoint(value) {
			context.beginPath();
			context.arc(value.x, value.y, 4, 0, 2 * Math.PI);
			context.stroke();
		}

		function drawTailPoint(value) {
			context.beginPath();
			context.arc(value.x, value.y, 2, 0, 2 * Math.PI);
			context.stroke();
		}

		function drawLocationIcon(x, y) {
			var radius = 10;
			if (tickNumber%2 == 0) {
				radius = radius - (radius/4);
			}
	    var targetBars = ((2 * radius) / 3);
	    var targetCircle = ( radius / 3);
			
			context.beginPath();
			context.lineWidth = 3;
			context.strokeStyle = "red";				
				
			context.arc(x, y , radius - targetCircle, 0, 2 * Math.PI);
			context.moveTo(x - radius, y);
			context.lineTo(x - radius + targetBars, y);	              	      
			context.moveTo(x + radius, y);
			context.lineTo(x + radius - targetBars, y);	              	      
			context.moveTo(x, y - radius, x);
			context.lineTo(x, y - radius + targetBars);	              	      
			context.moveTo(x, y + radius);
			context.lineTo(x, y + radius - targetBars);	              	      		
			 
			context.stroke();

			context.beginPath();
			context.lineWidth = 1;
			context.strokeStyle = "white";				

			context.arc(x, y , radius - targetCircle, 0, 2 * Math.PI);
			context.moveTo(x - radius, y);
			context.lineTo(x - radius + targetBars, y);	              	      
			context.moveTo(x + radius, y);
			context.lineTo(x + radius - targetBars, y);	              	      
			context.moveTo(x, y - radius, x);
			context.lineTo(x, y - radius + targetBars);	              	      
			context.moveTo(x, y + radius);
			context.lineTo(x, y + radius - targetBars);	 
			
			context.stroke();
		}

		function drawXonCanvas(x, y) {	
			debugLog(3, "drawXonCanvas: x: " + x + ", y:" + y);
			context.beginPath();
			context.lineWidth = 3;
			context.strokeStyle = "black";			
			var X_location_x = x;
			var X_location_y = y;
			var X_size = 20;
			//context.strokeStyle = '#00ff00';
			context.moveTo(X_location_x - X_size, X_location_y - X_size);			
			context.lineTo(X_location_x + X_size, X_location_y + X_size);
			context.moveTo(X_location_x - X_size, X_location_y + X_size);			
			context.lineTo(X_location_x + X_size, X_location_y - X_size);
			context.stroke();
		}

		function drawMap()
		{
			map_image = new Image();
			map_image.src = 'maps/1003/img.jpg';
			map_image.onload = function() {
				canvas.width  = map_image.width;
				canvas.height = map_image.height;
				context.drawImage(map_image, 0, 0);
				postInit();
			}
		}

		function reDraw() {			
			context.clearRect(0, 0, canvas.width, canvas.height);
			context.beginPath();
			context.closePath();
			context.drawImage(map_image, 0, 0);	
			showHistory();
			showTail();					
			showPosition(map_coords.x, map_coords.y);
		}

		function timeTick() {		
			tickNumber += 1;
			if (tickNumber > 100000) {
				tickNumber = 0;
			}	
			debugLog(4, "TimeTick:" + tickNumber);
			if (simulatorMode == true) {
				simulatorLocationTick();
			}
			reDraw();
		}

		function toRadians (angle) {
			return angle * (Math.PI / 180);
		}
		
		function toDegrees (angle) {
			return angle * (180 / Math.PI);
		}

		function prepareOrientationData() {
			debugLog(2, "prepareOrientationData()");
			mapOrientData.vector = calcGeoVector(mapOrientData.p1.lat, mapOrientData.p1.lon, mapOrientData.p2.lat, mapOrientData.p2.lon);
			var xyDist = distance(0, 0, map_image.width, map_image.height);
			mapOrientData.vectorRatio = xyDist / mapOrientData.vector.dist
			debugLog(3, "mapOrientData:" + JSON.stringify(mapOrientData));
			historyPointsMinDistance = xyDist / 50;			
			tailPointsMinDistance = xyDist / 100;
		}

		function distance(x1, y1, x2, y2) {			
			var distX = x2 - x1;
			var distY = y2 - y1;
			var dist = Math.sqrt(distX * distX + distY * distY);
			debugLog(3, "distX: " + distX + ", distY: " + distY + ", dist: " + dist);
			return dist;
		}

		function angleFromEast(lat1, lon1, lat2, lon2, dist) {
			var distOverLat = getDistanceFromLatLonInKm(lat1, lon1, lat2, lon1);			
			var angle = Math.asin(distOverLat/dist);
			debugLog(3, "Angle: Rad=" + angle + ", Deg=" + toDegrees(angle));	
			return angle;
		}

		function calcGeoVector(lat1, lon1, lat2, lon2) {
			debugLog(3, "calcGeoVector: #1:" + lat1 + ", " + lon1 + " #2:" + lat2 + ", " + lon2);			
			var vector = {angle: 0.0, dist: 0.0};									 						
			vector.dist = getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2);
			vector.angle = angleFromEast(lat1, lon1, lat2, lon2, vector.dist);
			debugLog(3, "vector: " + JSON.stringify(vector));
			return vector;
		}

		function latLon_2_xy(lat, lon) {
			var p = {x: 0.0, y: 0.0};
			debugLog(3, "latLon_2_xy: lat:" + lat + ", " + lon);
			var vector = calcGeoVector(mapOrientData.p1.lat, mapOrientData.p1.lon, lat, lon);
			// Assuming the top left corner of the image is 0,0 and the bottom right corner is the "100,100":
			angleDelta = mapOrientData.vector.angle - vector.angle;
			angle = mapOrientData.vector.angle - angleDelta;
			dist = vector.dist * mapOrientData.vectorRatio;
			debugLog(3, "dist: " + dist + ", angle:" + angle);

			p.x = Math.cos(angle) * dist;
			p.y = Math.sin(angle) * dist;
			debugLog(3, "p.x: " + p.x + ", p.y:" + p.y);

			return p;
		}

		// From StackOverFlow:
		// https://stackoverflow.com/questions/27928/calculate-distance-between-two-latitude-longitude-points-haversine-formula
		function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {
  		var R = 6371; // Radius of the earth in km
  		var dLat = toRadians(lat2-lat1);  // deg2rad below
  		var dLon = toRadians(lon2-lon1); 
  		var a = 
    		Math.sin(dLat/2) * Math.sin(dLat/2) +
    		Math.cos(toRadians(lat1)) * Math.cos(toRadians(lat2)) * 
    		Math.sin(dLon/2) * Math.sin(dLon/2); 
  		var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
			var d = R * c; // Distance in km
			debugLog(3, "getDistanceFromLatLonInKm: " + d);
  		return d;
		}

		function setMapOrientData() {				
			var dataJson = 
			/* 1002: Full Israel: *///{"ver":1,"ori_point_left_top_lat":"33.6389522","ori_point_left_top_long":"33.2235350","ori_point_right_bottom_lat":"29.0940005","ori_point_right_bottom_long":"36.8380370"};
			/* 1003: Road 1-443: */ {"ver":1,"ori_point_left_top_lat":"32.0476788","ori_point_left_top_long":"34.7729125","ori_point_right_bottom_lat":"31.6918620","ori_point_right_bottom_long":"35.3702941"};
			/* 1004: Australia Kalinburu:*/// {"ver":1,"ori_point_left_top_lat":"-14.2825752","ori_point_left_top_long":"126.6229404","ori_point_right_bottom_lat":"-14.3016826","ori_point_right_bottom_long":"126.6543544"};
			/* Street corner: */// testPoint = [-14.293615, 126.644603];
			/* 1005: Santiago: */ //{"ver":1,"ori_point_left_top_lat":"-33.2970122","ori_point_left_top_long":"-70.8912797","ori_point_right_bottom_lat":"-33.5966048","ori_point_right_bottom_long":"-70.2980180"};
			/* Pudahel street: */ //testPoint = [-33.447511, -70.777573];	
			/* 1006: NY: */ //{"ver":1,"ori_point_left_top_lat":"40.7533338","ori_point_left_top_long":"-74.2577155","ori_point_right_bottom_lat":"40.5209412","ori_point_right_bottom_long":"-73.8127692"};
			/* Verezano Bridge: */ //testPoint = [40.607508, -74.044776];		

			mapOrientData.p1.lat = dataJson.ori_point_left_top_lat;
			mapOrientData.p1.lon = dataJson.ori_point_left_top_long;
			mapOrientData.p2.lat = dataJson.ori_point_right_bottom_lat;
			mapOrientData.p2.lon = dataJson.ori_point_right_bottom_long;
		}

		function postInit() { // Runs after image loads:
			debugLog(3, "postInit...");
			prepareOrientationData();
			initLocation();
		}

		function init() {
			debugLog(2, "init...");
			setMapOrientData();	
			canvas = document.getElementById("map_canvas"),
			context = canvas.getContext('2d');		
			drawMap();
		}
		
		function initLocation() {
			if (simulatorMode == true) {
				gpsSimulatorInit();
			} else {
				initiate_watchlocation();
			}
		}

		function gpsSimulatorInit() {
			simulatorlocations = 
				[
					{lat: 32.0, long: 35.0}, {lat: 32.0, long: 35.01}, {lat: 32.0, long: 35.02}, {lat: 32.0, long: 35.03},
					{lat: 32.0, long: 35.04}, {lat: 32.0, long: 35.05}, {lat: 32.0, long: 35.06}, {lat: 32.0, long: 35.07},
					{lat: 32.0, long: 35.08}, {lat: 32.0, long: 35.09}, {lat: 32.0, long: 35.10}, {lat: 32.0, long: 35.11}					
				];
			simulatorlocationsIndex = 0;						
		}

		function simulatorLocationTick() {	
			var location = {lat: 0.0, long: 0.0};
			location.lat = simulatorlocations[simulatorlocationsIndex].lat;
			location.long = simulatorlocations[simulatorlocationsIndex].long;
			simulatorlocationsIndex += 1;
			if (simulatorlocationsIndex >= simulatorlocations.length) {
				simulatorlocationsIndex = 0;
			}
			setPosition(location.lat, location.long);			
		}

		function debugLog(severity, str) {
			if (debugLogsEnabled == false) {
				return;
			}
			if (severity <= debugSeverityLevel) {
				console.log(str);
			} 
		}

		window.onload = init;
    </script>
  </head>
  <body>
    <div>	  
		<button type="button" onclick="initiate_watchlocation();">Start Position</button>
		&nbsp&nbsp
		<button type="button" onclick="stop_watchlocation();">Stop Position</button>
		&nbsp&nbsp
		<button type="button" onclick="getCurrentLocation();">Get Location</button>
		&nbsp&nbsp
		<input type="text" id="info" name="info">	  
		&nbsp&nbsp
		<button type="button" onclick="applyLocation();">Apply Location</button>
		&nbsp&nbsp
		<input type="text" id="newLoc" name="newLoc">	  
    </div>
	<canvas id="map_canvas" name="map_canvas"></canvas>
  </body>
</html>